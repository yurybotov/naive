 2.5. Реализация определяющих слов

     Механизм  определяющих слов составляет одно из основных достоинств языка
 Форт,  главную  "находку"  его  создателей.  С его помощью программист может
 вводить  свои  типы  данных  и  структуры  управления,  задавая  их  внешнее
 синтаксическое  оформление  и  внутреннюю семантическую реализацию. Исходный
 строительный  материал  программист  может  брать из сравнительно небольшого
 исходного запаса слов-команд языка или создавать сам.

     Широкие выразительные возможности и вместе с тем компактность реализации
 этого  механизма  вытекают  из  того, что в его основе лежит фундаментальный
 принцип  частичной  параметризации.  Его  применению  в  традиционных языках
 программирования  мешал  громоздкий  аппарат  процедурного  вызова,  который
 считался  в  этих  языках  элементарным  и неделимым действием. В языке Форт
 конструкция  вызова  разложена  на  отдельные  составляющие  и  доступна "по
 частям",  в частности имеется доступ к адресу возврата и всему динамическому
 контексту вызова.

     В  сочетании  с  единым  механизмом  передачи  параметров  через  стек и
 компактной  реализацией  через  шитый  код  это дает недостижимый для других
 языков уровень свертки понятий.


                      : CONST CREATE , DOES> @ ;
                            4 CONST ХОР
                            5 CONST ОТЛ

                    /│\                         /│\                   /│\
  ┌──>┌─────┬─────┐  │            ┌─────┬─────┐  │      ┌─────┬─────┐  │
  │   │  3  │ "Х" │  │      Поле  │  5  │ "C" │  │      │  1  │ ":" │  │
  │   ├─────┼─────┤  │      имени ├─────┼─────┤  │      ├─────┴─────┤  │
  │   │ "О" │ "Р" │  │            │ "O" │ "N" │  │      │     ■─────│──┘
  │   ├─────┴─────┤  │            ├─────┼─────┤  │      ├───────────┤
  │   │     ■─────│──┘            │ "S" │ "T" │  │   ┌──│─────■     │
  │   ├───────────┤         Поле  ├─────┴─────┤  │   │  ├───────────┤
  │   │     ■─────│──┐      связи │     ■─────│──┘   │  │--> CREATE │
  │   ├───────────┤  │            ├───────────┤      │  ├───────────┤
  │   │     4     │  │      Поле  │     ■─────│──┐   │  │--> ]      │
  │   └───────────┘  │      кода  ├───────────┤  │   │  ├───────────┤
  │                  │      Поле  │--> CREATE │  │   │  │--> (;CODE)│
  │                  │      пара- ├───────────┤  │   └─>├───────────┤
  │   ┌─────┬─────┐  │      метров│--> ,      │  └─────>│           │
  │   │  3  │ "О" │  │            ├───────────┤    CALL:│ RPUSH(RI) │
  │   ├─────┼─────┤  │            │--> (;CODE)│         │ RI:=W+2   │
  │   │ "Т" │ "Л" │  └───────────>├───────────┤         │ goto NEXT │
  │   ├─────┴─────┤  ┌───────────>│  JSR DOES │         └───────────┘
  └───│─────■     │  │            ├───────────┤
      ├───────────┤  │            │--> @      │
      │     ■─────│──┘            ├───────────┤
      ├───────────┤               │--> EXIT   │
      │     5     │               └───────────┘
      └───────────┘

                         DOES: PUSH(W+2); PRUSH(RI);
                               RI:=RETJSR; goto NEXT;

     Рис. 2.8. Структура статьи определяющих и определяемых слов


     На  рис.  2.8  приведена  структура  словарных статей, возникающая после
 обработки определений

          : CONST  CREATE  ,  DOES>  @  ;
                4  CONST  ХОР    5  CONST  ОТЛ

     Там  же показана словарная статья для слова : , в теле которой находится
 точка CALL адресного интерпретатора.

     Поле  кода  статьи  CONST  содержит  адрес точки CALL, а поле параметров
 содержит  последовательность  ссылок  на  словарные статьи, скомпилированную
 адресным интерпретатором в соответствии с техникой шитого кода. Слово DOES>,
 входящее  в  это определение, имеет признак немедленного исполнения, поэтому
 оно  не компилируется вслед за ссылкой на статью для запятой, а исполняется.
 Его  исполнение состоит в компиляции ссылки на статью вспомогательного слова
 (;CODE)   и   компиляции  машинной  команды  JSR  перехода  с  возвратом  на
 специальную  точку  DOES  в ядре форт-системы. Далее текстовый интерпретатор
 компилирует ссылку на статью для @ и исполняет (в силу признака немедленного
 исполнения)  слово  ;,  которое  завершает  построение словарной статьи. Оно
 компилирует  ссылку  на  статью EXIT и переключает текстовый интерпретатор в
 состояние исполнения.

     Во время исполнения слова CONST во фрагменте 4 CONST ХОР входящее в него
 слово  CREATE  создаст для слова ХОР заголовок словарной статьи и поле кода,
 заслав  туда стандартный адрес. Следующее слово, скомпилирует число 4 в поле
 параметров,  а  слово  (;CODE)  занесет  в  поле кода адрес следующей за ним
 машинной программы и закончит исполнение слова CONST:

          : (;CODE) ( ---> )  R>  LATEST  NAME>  !  ;

     Значение,  снимаемое  с  вершины стека возвратов словом R>,- это как раз
 адрес  команды  JSR  в  определении слова CONST. Слово LATEST кладет на стек
 адрес  заголовка последней созданной статьи, т. е. статьи ХОР, а слово NAME>
 преобразует  этот адресов адрес поля кода. Поскольку со стека возвратов было
 снято  одно  значение,  то  по  завершении  данного  определения  управление
 вернется  в  точку  после  вызова  определения,  вызвавшего данное, т. е. на
 продолжение  работы  после  вызова  слова  CONST. Аналогичные действия будут
 исполнены  при  обработке  текста  5  CONST ОТЛ. Если теперь слово ХОР будет
 исполняться,  то  из  точки  NEXT  адресного интерпретатора управление будет
 передано  на машинную программу по адресу из поля кода, т. е. на команду JSR
 в  теле  определения  CONST.  Эта  команда  перехода  с  возвратом  передает
 управление на точку DOES, сообщив ей в качестве своего адреса возврата адрес
 следующей  последовательности ссылок - исполняющей части определения CONST .
 Точка  DOES кладет на стек адрес поля параметров статьи ХОР (в этот момент в
 рабочей  ячейке W еще находится адрес поля кода статьи ХОР, загруженный туда
 действием  NEXT) и исполняет действие CALL для исполняющей части определения
 CONST.  Следующее исполняемое слово @ заменит на стеке адрес поля параметров
 статьи  ХОР  числом  4, скомпилированным по этому адресу, и затем слово EXIT
 завершит исполнение данного вызова слова ХОР.

     Слово  :  тоже является определяющим, и его словарная статья имеет такую
 же структуру. Рассмотрим его работу на примере трансляции определения CONST.

     Создающая  часть  слова : состоит из слов CREATE и ]. Первое выбирает из
 входной  строки  следующее  за  двоеточием  слово  (в данном случае CONST) и
 создает  для  него начало словарной статьи (заголовок и поле кода), а второе
 переключает  текстовый  интерпретатор  в  состояние  компиляции. Последнее в
 создающей части слово (;CODE) вписывает в поле кода создаваемой новой статьи
 текущее  значение  указателя  интерпретации, т. е. адрес точки CALL, которая
 располагается  в  теле  данного определения, после чего исполнение двоеточия
 заканчивается.   Поскольку   теперь   интерпретатор  находится  в  состоянии
 компиляции, то следующие вводимые слова будут компилироваться, заполняя поле
 параметров  статьи  CONST последовательностью ссылок. Так будет продолжаться
 до  тех  пор,  пока  слово - точка с запятой, отмечающее конец определения и
 имеющее признак немедленного исполнения, не переключит интерпретатор обратно
 в состояние исполнения:

          : ;  ( ---> )  COMPILE  EXIT  [COMPILE]  [  ;  IMMEDIATE

     Определяющие  слова  являются  механизмом  для  создания классов слов со
 сходным "поведением", которое определяется исполняющей частью и включается в
 словарную  статью слова через поле кода. Разница между словами внутри одного
 класса  состоит в значении поля параметров, которое строится при определении
 слова.  Слова,  определенные  через  двоеточие,  составляют  один из классов
 наряду   с  константами,  переменными,  списками  слов  и  другими,  которые
 программист  может  вводить  по  своему  усмотрению.  При  этом  достигается
 существенная  экономия памяти за счет того, что общая часть всех слов одного
 класса   присутствует   в   памяти   в   единственном  экземпляре  в  статье
 определяющего слова.

     Таким    образом,   в   основе   языка   Форт   лежат   две   структуры:
 внешняя-простейшая   синтаксическая  структура  слова,  представленного  как
 последовательность  литер,  ограниченная  пробелом, и внутренняя - структура
 словарной  статьи, в которой поле кода задает интерпретатор поля параметров.
 Одним   из   частных   случаев   такого   интерпретатора  является  адресный
 интерпретатор,   и   тогда   поле   параметров  содержит  последовательность
 интерпретируемых  адресов  в  шитом  коде. Этому случаю отвечает определение
 через  двоеточие.  Другие  определяющие слова задают другие интерпретаторы и
 соответственно другие структуры поля параметров.
