Prehistoric

Мне захотелость переписать под себя ассемблер stm8. Хороший контроллер, с реально высоким относительным быстродействием, 
даже на С. НО! Его язык ассемблера ужасен. Его это язык для компилятора: чтобы кто то один раз помучался с написанием
компилятора, допустим "С", а остальные этого ассемблера даже не увидят...
За что я не люблю ассемблер stm8? Меня пугают "устаревшей архитектурой" с одним аккумулятором, вот даже у avr целых 32
регистра... - чушь! Первые 256 байт памяти stm8 по сути равноценны регистрам avr - к ним укороченный и ускоренный доступ.
Так что 1-2х тактовый LD  у stm8 по сравнению с 4х тактовым у avr это супер!
Но ассемблер...
Бесит то что для загрузки в аккумулятор (индексы) и выгрузки из них используется одна и таже команда - ld. Мозг протестует,
хочет для выгрузки что то типа st. Бесит то что везде надо писать то что не используется: ld a,#123 . 
Ld может быть только в a! Или из a... Если это индексный регистр то в него тоже можно ld, но оно уже ldw! Ldw x,#123 .
Неужели по имени регистра ассемблер не может понять какую команду в кодах вызвать? И это просто один пример... Есть
можество других прмеров абсолютной нечитаемости кода. Как вы думаете что делают команды с аббревиатурой jruge или btjt?

History

Подумалось: а что нельзя тупо как а арифметике? Как в "С", ну на худой конец как "BASIC"? Да, с учетом архитектуры, да
так чтобы одна команда == одной команде ассемблера. Оказалось... в принципе... вроде как... можно!

Description

Получившийся язык, на что бы он там не был похож - он все равно ассемблер. И это надо осознавать и четко понимать.
Посему никаких встроенных циклов, никакой динамической памяти. Все ручками. Но на мое ИМХО все значительно понятнее для
стороннего наблюдателя. Побочный эффект... это можно переписать почти под любую другую систему команд! Когда закончу stm8 
попробую avr и msp430.

Чуть чуть вводной информации. Память в контроллерах бывает 7 видов:
- непосредственно регистры процессора
- flash - где обычно живет текст программы и константы
- дальнюю flash - она вроде как и доступна, но она медленнее чем обычная, и с ней доступны далеко не все методы аддресации
- eeprom - тут обычно хранят долгоживущие данные, например конфигурацию
- регистры портов ввода вывода маппированные в память
и собственно оперативную память... потенциально трех типов
    - квазарегистровую - многие контроллеры имеют область памяти для которой есть некие особые преференции по скорости 
        и размеру кода, например, в тех же avr, все регистры контроллера (32) доступны в адресном пространстве памяти, 
        что позволяет организовывать их как массив и т.п. В stm8 это первые 256 байт.
    - обычную - с ней обычно и работают как с памятью, она ограничена "системным int" и щедростью производителя
	- внешнюю - тут ее нет

В данном языке программирования переменные надо объявлять, причем объявляются не тип, а место где переменную раположить.
Общий вид объявления:
имяпеременной{@адрес}:(bc) {значениепеременной}
То что в фигурных скобках не обязательные (но порой необходимые) параметры
(bc):
b == e или f или m или r или u - eeprom/flash/huge flash/memory/register/universal
c == 8 или 16 или 32 - число бит в данной переменной/константе
universal - используется обычно для портов ввода/вывода и других нестандартных областей памяти, он не выделяет память для переменной
и для него нельзя задать значение переменной.
Важно: задать значение переменной можно только для eeprom или flash памяти. Только в них оно реально сохранится. Если
нужна инициализированная ram - это на совести программиста, тогда надо создать копии в eeprom или flash и скопировать их 
в ram при старте.
Для кода программы немного упрощенная система:
Для программы в flash:
имяметки: {кодпрограммы}
если вы принудительно указываете адрес то вид флэша определяется автоматически по адресу:
имяметки@адрес: {кодпрограммы}
Примеры объявления меток и переменных:
resetvector@0x000: (f32) start
trapvector: (f32) dumb
dumb: iret
start:
Инициализация переменных может быть
Для x8 '1' / 0x00 / 123
Для x16 0x0000 / 12345 / @labelname
Для x32 0x0000 / 12345678 / @labelname
Допустимы массивы
arrayname: (r8)[16]
И массивы тоже можно инициализировать:
Для x8 "12345" / '12',3,0x4,'5' - каждый символ строки и число будут положены в отдельный байт. В строке недопустим 
	символ ";" - если нужно вставляйте его как число: "asds",59,"asd"
Для x16 0x0000,0x45,1,@labelname - каждое число или адрес метки будут положены в отдельное 16 битное слово
Для x32 0x00000000,0x454521,33,@labelname - каждое число или адрес метки будут положены в отдельное 32 битное слово 
(Врезка: пробелы и табуляции в коде ВООБЩЕ НИЧЕГО НЕ ЗНАЧАТ. Все будут удалены ДО компиляции. 
Потому для наглядности вставляйте их где угодно и сколько душе угодно. Исключение есть: это команды препроцессора) 
Вот пример того что можно:
interrupt flash:        (u32f) dumb   превратится в  interruptflash:(u32f)dumb
Препроцессор? Тут есть препроцессор? Есть. Простейший. Синтаксически подобный языку "С". Есть всего несколько команд:
include filenamewithpath - включает вместо себя тело указанного файла
define name value - определяет некую константу, начиная с места определения если имя этой константы встречается в тексте
    основной программы происходит замена имени на значение. Функциеподобные макросы не поддерживаются. Осторожннее с именами
    - замена производится тупо, в том числе внутри и на пересечении других слов. Выбирайте имена позаковырестее.
undef name - удаляет определение константы, после удаление встреченные имена уже не будут ничем заменяться.
ifdef name - условная вставка кода "отсюда до endif" если константа определена
ifndef name - условная вставка кода "отсюда до endif" если константа НЕ определена - обычно используется для запрещения 
дублирования включаемых файлов
endif - метка конца для двух предыдущих команд
Команды препроцессора должны занимать отдельную строку. Пробелы могут быть любым количеством пробелов и табуляций. 
В конце строки может быть комментарий после "//". ДАЖЕ после define!
Есть "секретный define" - если добавить пару ключ|значение в отдельную строку файла naive.cfg то это все равно что объявить
эту пару через define.
Комментарий "//" может использваться вообще везде, разумеется только в конце строки. Многострочный комментарий 
отсутствует как класс.
Что касается команд процессора, то можно их писать и по несколько в строке (если это вдруг удобно) просто не забывайте 
ставить между ними ";":
temp: (r8)
a = 100; a += 1; temp = a --> temp = 100 + 1
Точка с запятой в конце не нужна, но не запрещена.
Ну да, чем-то похоже на "С" - но это не "С"!
Во первых каждая (допустимая) команда однозначно преобразуется ровно в одну команду ассемблера процессора.
А значит недопустимы ВЫРАЖЕНИЯ, такие как: a = b + (c-1) / 2 - их придется разбивать по частям.
Отсутствуют операторы цикла! Однако используя условные if и метки они легко реализуются.
Нет автоматических и динамических переменных. Распределение памяти на вашей совести. Про уборку мусора вообще молчу.
Что есть... скорость выше чем у "С", размер кода - меньше. А если вам этого не надо... то уже никакой ассемблер не поможет, 
программируйте на "С".
Пора немного дать информации об архитектуре stm8 и соответственно о "правилах поведения" с регистрами.
В stm8 использована архитектура с одним аккумулятором и двумя индексными регистрами:
a - 8 битный аккумулятор. С ним можно любое присваивание, любые арифметические и логические операции, для умножения и деления
    он всегда только второй аргумент, результат будет в x или в y.
x - 16 битный "индексный" регистр, доступны сложение, вычитание, возможен как множитель или делитель, доступен как индекс для
    a, себя или y
xl и xh - соответственно младший и старший байты регистра x
y - 16 битный "индексный" регистр, доступны сложение, вычитание, возможен как множитель или делитель, доступен как индекс для
    a, себя или x
yl и yh - соответственно младший и старший байты регистра y
    x от y, как правило, при использовании отличаются лишним (для y) байтом кода в команде, и меньшим количеством доступных режимов
	адресации посему если нужен один регистр - выбирайте x. Во всем прочем - они практически равноценны.
sp - 16 битный указатель стэка, как правило устанавливается на конец обычной памяти. Квазирегистровая память "дорога",
    а push/pop одинаково общаются и с обычной и с квазирегистровой памятью. Умеет общаться с x и y. Еще ему можно присвоить, 
	добавить или вычесть константу. Другие операции недоступны.
ip - 24 битный указатель на инструкцию. Ввиду своей 24 битности может выполнять код откуда угодно: хоть из flash, хоть из 
    eeprom, хоть из области загрузчика, хоть из обычной и дальней озу. Ему ничего нельзя присвоить кроме как с использованием
    ret, retf, iret и операций перехода и вызова подпрограмм 
cc - так в stm8 называют 8 битный регистр флагов, как таковой его можно только сохранить в стэке или извлечь из него push/pop cc, 
но к его битам можно обращаться по отдельности:
c - флаг переноса (1-был перенос при арифметической операции)
z - флаг равенства нулю (1-нулевой результат последней операции)
n - флаг знака (1-результат последней операции имел старший бит равным 1)
i0,i1 - флаги разрешения прерываний (см. таблицу в документации)
h - флаг "полупереноса" (переноса между ниблами)
v - флаг переполнения (1-при последней операции возникло переполнение (обычно * или /))