include targets/stm8s003._

//
// 'blink' with timer1 and clock setup
// uses external quarz 8 MHz
//

define led	3

// interrupt vectors
interrupt reset@0x8000: (f32) {0x82000000+start}
interrupt trap:         (f32) {0x82000000+dumb}
interrupt tli:          (f32) {0x82000000+dumb}
interrupt awu:          (f32) {0x82000000+dumb}
interrupt clk:          (f32) {0x82000000+dumb}
interrupt exti0:        (f32) {0x82000000+dumb}
interrupt exti1:        (f32) {0x82000000+dumb}
interrupt exti2:        (f32) {0x82000000+dumb}
interrupt exti3:        (f32) {0x82000000+dumb}
interrupt exti4:        (f32) {0x82000000+dumb}
interrupt canrx:        (f32) {0x82000000+dumb}
interrupt cantx:        (f32) {0x82000000+dumb}
interrupt spi:          (f32) {0x82000000+dumb}
interrupt tim1u:        (f32) {0x82000000+tmr1handler}
interrupt tim1c:        (f32) {0x82000000+dumb}
interrupt tim2u:        (f32) {0x82000000+dumb}
interrupt tim2c:        (f32) {0x82000000+dumb}
interrupt tim3u:        (f32) {0x82000000+dumb}
interrupt tim3c:        (f32) {0x82000000+dumb}
interrupt uart1tx:      (f32) {0x82000000+dumb}
interrupt uart1rx:      (f32) {0x82000000+dumb}
interrupt i2c:          (f32) {0x82000000+dumb}
interrupt uart3tx:      (f32) {0x82000000+dumb}
interrupt uart3rx:      (f32) {0x82000000+dumb}
interrupt adc1:         (f32) {0x82000000+dumb}
interrupt tim4u:        (f32) {0x82000000+dumb}
interrupt flash:        (f32) {0x82000000+dumb}

dumb: iret

tmr1handler:
	if tim1 sr1#0 == 0 otherint			// is this right interrupt?
	tim1 sr1#0 = #0					// drop flag
	! gpioa odr#led					// change led state
otherint: iret

init:   // led port
	gpioa ddr#led = #1                           	// for output     
        gpioa cr1#led = #1                           	// set push-pull
	// timer1
 	tim1 cr2 = #0					// no sync with master
	tim1 smcr = #0					// no sync for slave
	tim1 etr = #0					// external clock disable
	tim1 ier#0 = #1					// change interrupt granted
	tim1 pscrh = #0					// prescaler 0015
	tim1 pscrl = #10                                // 
	tim1 cr1#0 = #1                                  // overflow interrupt granted
	tim1 cr1#2 = #1                                  // clock started
	// system clock
	clk eckr#0 = #1					// hse switch on
	clk swcr#1 = #1					// grant switch to hsi if need	
wait1:	if clk eckr#1==0 wait1				// ready wait
	clk ckdivr = #0					// zero prescaler
	clk swr = #0xb4					// select hse as source
wait2:	if clk swcr#3 ==0 wait2				// ready wait
	ret

// main block
start:	x = #ramend; sp = x                       	// initialise stack pointer (it is assembler!!!)
	call near init
	i=#1						// interrupts switch on
loop:   nop                                             // wait for interrupts
	go near loop					// forever cycle

 
 
