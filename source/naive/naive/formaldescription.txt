Naive - альтернативный синтаксис языка ассемблера для контроллеров STM8

(Описание предварительное, оно не полно и скорее всего содержит опечатки и ошибки)

Описание синтаксиса и ограничений

Общие положения:

Имя исходного файла должно иметь вид: name.base._ где:
name - произвольное допустимое имя файла
base - сейчас допустимы 2 варианта: stm8s и stm8l в зависимости от base транслятор меняет некоторые внутренние опции
_ - символ подчеркивания

В каталоге с проектом должен присутствовать файл naive.cfg - в нем необходимо указать реальные пути для данного проекта:
naive_path - путь к файлу naive.exe
naive_targets_path - путь к папке описаний целевых процессоров
naive_libs_path - путь к папке библиотек
stm8s_sdk_path - путь к стандартному sdk stm8 (stvd)
user_code_path - путь к папке откуда будут браться файлы исходного кода проекта (как правило текущий путь)
user_output_path - путь по которому транслятор будет складывать результаты своей работы
Не забывайте в конце пути знак "\".
При необходимости, в этом файле можно разместить и другие пары "ключ|значение". Указание их тут равноценно установке
с помощью define в коде программы.
Транслятор не поддерживает сборку из нескольких файлов в процессе линковки. Однако можно подключить дополнительные
файлы с помощью препроцессора.

Препроцессор:

Простой, С-подобный. Каждая команда занимает ровно одну строку, нельзя перенести часть команды на следующую строку. 
В конце строки можно использовать строчный комментарий начинающийся с "//". Допустимые команды:
include filename.ext - эта команда убирается из потока, а на место ее вставляется содержимое указанного файла
	Поиск файла производится сначала в текущем каталоге, потом в каталоге на который указывает "naive_targets_path", 
	потом в каталоге на который указывает "naive_libs_path". Если файла нет - выдается сообщение об ошибке.
define name - определяет макрос-константу с именем name и значением "пустая строка"
define name value - определяет макрос-константу с именем name и значением value
define name(x{,y{,z}}) code - определяет макрос с праметрами. Он значительно проще чем соответствующая конструкция в 
	языке "С". Когда встречается соответствующая строка в тексте программы из нее берутся параметры "как есть" с пробелами,
	скобками и т.п. и подставляются в строку code на место параметров макроса, после чего весь вызов макроса заменяется
	на модифицированную строку code. При несоответствии количества параметров при определении и вызове - ошибка.
	Внутри "функции" можно использовать локальные метки вида @0...@f - соответственно не более 16 штук, они будут при 
	раскрытии заменены на недублирующиеся.
undef name - убирает из памяти макрос с таким именем. Дальше в тексте программы соответствующие подстановки данного макроса 
	производиться не будут.
ifdef name - если имя name не определено весь код вплоть до парного endif будет проигнорирован. Можно использовать в
	качестве отсутствующих в синтаксисе блочных комментариев.
ifndef name - если имя name определено весь код вплоть до парного endif будет проигнорирован. Часто используется для 
	недопущения повторного включения тела файла.
endif - "закрыывающий тэг" для двух предыдущих команд.
Ограничения: подстановка производится "как есть", может выполниться и внутрь текстовой строки и в любое другое "неожиданное"
место, в случае define с параметрами, если параметр окружить скобками, он так со скобками и будет вставлен. Просто это надо помнить.

Транслятор:

Транслятор naive не создает бин-файл, он преобразует файл с альтернативным синтаксисом в ассемблерный файл со стандартным 
синтаксисом, который в дальнейшем обрабатывается штатным ассемблером st. Файл результата можно посмотреть в выходной папке.
Транслятор однопроходный, построчный. Соответственно никакую команду или макрос нельзя разместить в нескольких строках.
ВСЕ пробелы и табуляции убираются. Поэтому можно достаточно произвольно вставлять их даже внутри имен переменных и т.п. НО
они убираются и из строк, поэтому в строках приходится вставлять пробел как его цифровой код - "\032".

Начало работы:

Проще всего скопировать папку template под другим именем и скорректировать naive.cfg и template.stm8s._
В начале файла подключить файл соответствующего целевого семейства контроллеров (раскомментировать нужный, закомментировать 
или стереть ненужное). 
Скорректировать таблицу обработчиков прерываний, естественно, таблица прерывание должна быть в самом начале файла,
	до нее нельзя размещать переменные и константы размещаемые во flash и выполнимый код.
Добавить определения переменных и констант. После таблицы обработчиков прерываний!
Собственно написать код, возможно какую то его часть подключая из других файлов используя include.
Не забывайте в начале прописать вектора прерываний и инициализировать стэк. 

Области памяти:
В stm8 версии naive есть несколько подразумеваемых областей памяти:
r - какбы-регистровая ram - первые 256 байт памяти. Команды обращения к ней короче и быстрее выполняются
m - просто ram, от 0xFF до конца ram
e - eeprom - память хранения для данных
f - flash - память для кода и данных, в начале flash должна находиться таблица обработчиков прерываний
u - unifyed - просто указатели на что угодно без привязки к конкретному региону. Используются, например, 
	для привязки регистров периферийных устройств.
Для простоты использования в файлах описаний контроллеров указаны границы для регионов:
define regstart 0x0
define regend 0x00ff
define ramstart 0x100
define ramend 0xXXX
define eepromstart 0x4000
define eepromend 0xXXXX
define flashstart 0x8000
define flashend 0xXXXX

Переменные и константы:

Общий вид - labelname@addr: (x00) val - где
labelname - имя переменной (не обязательное)
addr - адрес привязки переменной (не обязательный, когда его нет @ тоже не пишется)
x - место расположения переменной (r/m/e/f/u) - по первой букве региона памяти.
00 - цифра (8/16/32) - размер переменной в битах - байт/слово/двойное слово
val - значение которым инициализируется переменная, можно инициализировать только переменные располагаемые в flash или eeprom!
При необходимости инициализировать переменную в ram необходимо написать соответствующий код (создать инициализированную константу
во flash или eeprom и скопировать ее значение в ram)
Кроме одиночных переменных можно объявлять и массивы: arrname: (x00)[size] val1,val2,'3'... Ограничения как у переменных.
	Для байтовых массивов допустима инициализация как строки "в двойных кавычках".
Числовые константы в десятичной системе счисления представляются просто положительными цыфрами 123,0,1... В шестнадцатиричной
системе счисления как в "С" 0x00,0x11ab. Нельзя использовать отрицательные константы! При необходимости записывается дополнение
до единицы хранения. Так для байта, например, -1 == 0xFF и т.д.

Специфика stm8 - регистры и флаги:

В stm8 использована архитектура с одним аккумулятором и двумя индексными регистрами:
a - 8 битный аккумулятор. С ним можно любое присваивание, любые арифметические и логические операции, для умножения и деления
    он всегда только второй аргумент, результат будет в x или в y.
x - 16 битный "индексный" регистр, доступны сложение, вычитание, возможен как множитель или делитель, доступен как индекс для
    a, себя или y
xl и xh - соответственно младший и старший байты регистра x
y - 16 битный "индексный" регистр, доступны сложение, вычитание, возможен как множитель или делитель, доступен как индекс для
    a, себя или x
yl и yh - соответственно младший и старший байты регистра y
    x от y, как правило, при использовании отличаются лишним (для y) байтом кода в команде, и меньшим количеством доступных режимов
	адресации посему если нужен один регистр - выбирайте x. Во всем прочем - они практически равноценны.
sp - 16 битный указатель стэка, как правило устанавливается на конец обычной памяти. Квазирегистровая память "дорога",
    а push/pop одинаково общаются и с обычной и с квазирегистровой памятью. Умеет общаться с x и y. Еще ему можно присвоить, 
	добавить или вычесть константу. Другие операции недоступны.
ip - 24 битный указатель на инструкцию. Ввиду своей 24 битности может выполнять код откуда угодно: хоть из flash, хоть из 
    eeprom, хоть из области загрузчика, хоть из обычной и дальней озу. Ему ничего нельзя присвоить кроме как с использованием
    ret, retf, iret и операций перехода и вызова подпрограмм 
cc - так в stm8 называют 8 битный регистр флагов, как таковой его можно только сохранить в стэке или извлечь из него push/pop cc, 
но к его битам можно обращаться по отдельности:
c - флаг переноса (1-был перенос при арифметической операции)
z - флаг равенства нулю (1-нулевой результат последней операции)
n - флаг знака (1-результат последней операции имел старший бит равным 1)
i0,i1 - флаги разрешения прерываний (см. таблицу в документации)
h - флаг "полупереноса" (переноса между ниблами)
v - флаг переполнения (1-при последней операции возникло переполнение (обычно * или /))

Команды:

Присваивание:

Учитывая специфику аккумуляторной архитектуры, принято все операции делать с аккумулятором, но
в stm8 эта архитектура слегка расширена. Для 16 битных чисел роль аккумулятора могут выполнять индексные регистры,
и даже есть 8-битная пересылка память->память без использования аккумулятора. Все операции присваивания носят одинаковый 
внешний вид "a=b", однако надо помнить что каждая инструкция это ровно одна инструкция ассемблера, поэтому
далеко не все сочетания а и b допустимы.
Обозначения:
const - числовая константа
mem8 - ячейка 8 бит в любой области памяти в пределах 0-0xffff
mem16 - ячейка 16 бит в любой области памяти в пределах 0-0xffff
label - имя метки
bit - номер бита в байте
(имена регистров и флагов)
01 - #1 или #0
Допустимые присваивания:
mem8=#const; mem8=mem8
a=xl; a=xh; a=yl; a=yh; xl=a; xh=a; yl=a; yh=a;
a=#const; a=mem8; a=mem16[x];  a=mem16[y];  a=x[const];  a=y[const]; a=[x]; a=[y]; a=[mem16]; a=[mem16[x]]; a=[mem16[y]]; a={mem16[x]}
mem8=a; mem16[x]=a;  mem16[y]=a;  x[const]=a;  y[const]=a; [x]=a; [y]=a; [mem16[x]]=a; [mem16[y]]=a; {mem16[x]}=a
x=y; x=sp; x=#const; x=#label; x=mem16; x=[x]; x=[mem16]; x=mem16[x]; x=[mem16[x]]; mem16=x; [x]=y; mem16[x]=y; [mem16]=x; sp=x
y=x; y=sp; y=#const; y=#label; y=mem16; y=[y]; y=[mem16]; y=mem16[y]; y=[mem16[y]]; mem16=y; [y]=x; mem16[y]=x; [mem16]=y; sp=y
c=#0; c=#1; z=#0; z=#1; v=#0
mem8#bit=#0; mem8#bit=#1

Управление исполнением:

Метка имеет вид - labelname: - она может стоять одна в строке или после нее может быть команда ассемблера.

go labelname - безусловный переход в пределах 65535 байт
go near labelname - безусловный переход в пределах 127 байт
go far labelname - безусловный переход в пределах всего адресного пространства
call labelname - вызов подпрограммы в пределах 65535 байт
call near labelname - вызов подпрограммы в пределах 127 байт
call far labelname - вызов подпрограммы в пределах всего адресного пространства
ret - возврат из подпрограммы
retf - возврат из подпрограммы вызванной через call far
trap - переход к "ловушке" 
halt - остановка процессора
wait - остановка процессора с ожиданием внешнего события
waiti - остановка процессора с ожиданием прерывания
nop - пропуск такта
if condition labelname - условный переход в пределах 127 байт. Проверяется условие: состояние флага или сочетания флагов, или
	состояние прерывания или состояния бита по адресу, и выполняется переход по метке (true) или к следующей операции (false) 
Варианты условий:
z==0 - результат последнего вычисления равен 0
z==1 - результат последнего вычисления не равен 0
с==0 - в результате последнего вычисления установлен бит переноса
с==1 - в результате последнего вычисления сброшен бит переноса
h==0 - в результате последнего вычисления установлен бит полу-переноса (переноса в нибле)
h==1 - в результате последнего вычисления сброшен бит полу-переноса (переноса в нибле)
i==0 - прерывания разрешены
i==1 - прерывания замаскированы
v==0 - в результате последнего вычисления установлен бит переполнения
v==1 - в результате последнего вычисления сброшен бит переполнения
<0 - результат последнего вычисления меньше 0
>=0 - результат последнего вычисления больше или равен 0
<>0 или !=0- результат последнего вычисления не равен 0
...
int==0 - прерывания не было
int==1 - прерывание было
mem8#bit==0 - состояние указанного бита = low
mem8#bit==1 - состояние указанного бита = high
Обратите внимание: в условиях, при сравнениях, константы используются без префикса "#"!
true - всегда уходить на метку - странный на первый взгляд оператор, однако очень полезен при отладке, как и следующий..
false - всегда переходить к следующему оператору

Арифметика и логика:

Операнды могут иметь разные режимы адресации, вот например для сложения двух чисел:
a+=#1;a+=mem8;a+=[x];a+=[y];a+=mem16[x];a+=mem16[y];a+=[mem16];a+=[mem16[x]]
Обобщенный вид сложения: d+=s								d=d+s
Обобщенный вид вычитания: d+=s								d=d-s
Обобщенный вид сложения с учетом переноса: d+=с+s			d=d+s+с
Обобщенный вид вычитания с учетом заимствования: d+=с+s		d=d-s-с
Умножение доступно только в двух вариантах: x*=a или y*=a
Деление в трех: x/=a или y/=a и отдельно
16 битное деление x/%y - делит x на y, результаты: в x - частное, в y - остаток от деления
Обобщенный вид логического И: d&=s							d=d&s
Обобщенный вид логического ИЛИ: d|=s						d=d|s
Обобщенный вид логического XOR: d^=s						d=d^s
Инкремент: ++d или d++										d=d+1 (положение ++ роли как в "С" не играет, это отдельная операция!)
Декремент: --d или d--										d=d-1 (положение ++ роли как в "С" не играет, это отдельная операция!)
Смена знака: -d												d=-d
Инверсия: !d

Проверки:

Условные операторы работают с текущим состоянием флагов, однако иногда нужно вычислить одно, а принять решение на основе другого
для этого есть операции проверки:
a?s - сравнить аккумулятор со вторым операндом (a-s) выставить флаги а результат не сохранять
a&?s - сравнить аккумулятор со вторым операндом (a&s) выставить флаги а результат не сохранять
?s - проверить для данного операнда n-знак и z-равенство нулю и выставить флаги

Сдвиги:

Бывает нужно выполнить разного рода сдвиги байта или слова, это тут нужно реже чем в других контроллерах
	из за наличия побитовых операций, но все равно нужно. Есть:
c<<c d - сдвиг операнда d влево на 1 бит, закольцованный через бит переноса - с
c>>c d - сдвиг операнда d вправо на 1 бит, закольцованный через бит переноса - с
c<<0 d - сдвиг операнда d влево на 1 бит, левый разряд выталкивается в бит переноса - с , а правый заполняется нулем
s>>c d - сдвиг операнда d вправо на 1 бит, правый разряд выталкивается в бит переноса - с , а левый заполняется битом знака
a<<a z - 16 битный сдвиг x или y на единицу влево закольцованный через аккумулятор
a>>a z - 16 битный сдвиг x или y на единицу вправо закольцованный через аккумулятор

Стэк:

Доступны push и pop в вариантах:
push a; push #const; push cc; push mem8
pop a; pop cc; pop mem8
Для произвольного доступа есть:
a=sp[const];  x=sp[const]; y=sp[const]; sp[const]=a; sp[const]=x; sp[const]=y;

Разное:
swap d
a<->b
